\chapter{Теоретические вопросы}

\section*{Вопрос 1. Элементы языка: определение, синтаксис, представление в памяти}
\subsection*{Элементы языка и их определение}

Вся информация (данные и программмы) в Lisp представляется в виде символных выражений	 --- \texttt{S-выражений}. По определению:

\texttt{S-выражение := <атом>|<точечная пара>}

Элементами языка Lisp являются атомы и точечные пары (структуры). К атомам относятся:
\begin{enumerate}[label=\arabic*)]
	\item символы (идентификаторы) --- набор литер, начинающихся с буквы;
	\item специальные символы для обозначения логических констант {\texttt{T,~Nil}};
	\item самоопределимые атомы --- натуральные числа, дробные числа, вещественные числа, строки (последовательность символов, заключённых в двойные апострофы).
\end{enumerate}

\noindent{\texttt{Точечные пары ::= (<атом>, <атом>) |}}

{\texttt{(<атом>, <точечная пара>) |}}

{\texttt{(<точечная пара>, <атом>) |}}

{\texttt{(<точечная пара>, <точечная пара>)}}


\noindent{\texttt{Список ::= <пустой список> | <непустой список>)}}, где

{\texttt{<пустой список> ::= () | Nil}},

{\texttt{<непустой список> ::= (<первый элемент>, <хвост>)}},

{\texttt{<первый элемент> ::= (S-выражение)}},

{\texttt{<хвост> ::= <список>}}

\subsection*{Синтаксис элементов языка и их представление в памяти}

Синтаксически любая структура (точечная пара или список) заключается в {\texttt{()}}:\\
{\texttt{(A . B)}} -- точечная пара\\
{\texttt{(A)}} -- список из одного элемента\\
Пустой список изображается как {\texttt{Nil}} или {\texttt{()}}\\
Непустой список может быть изображён: {\texttt{(A. (B . (C ())))}} или {\texttt{(A B C)}}\\
Элементы списка могут являться списками: {\texttt{((A) (B) (C))}}\\
Любая непустая структура {\texttt{Lisp}} в памяти представлена списковой ячейкой, хранящей два указателя: на голову (первый элемент) и хвост (всё остальное).

	
\section*{Вопрос 2. Особенности языка Lisp. Структура программы. Символ апостроф}

Lisp --- интерпретируемый символьный язык программирования, т.е. язык программирования, предназначенный для символных вычислений и преобразований, символьной обработки.

Программа и данные в Lisp представлены списками, поскольку программа --- текст, и синтаксического различия между программой и данными нет.
Это даёт возможность выдать программу за данные и заставить её менять саму себя.
По умолчанию список считается вычислимой формой, в которой первый элемент --- название функции, остальные элементы - аргументы функции.

В основе языка Lisp лежит $\lambda$-исчисление, согласно которому, любые вычислительные выражения могут быть преобразованы в вид функций от 1-го аргумента.

Поскольку программа и данные представлены списками, то их нужно как-то различать. 
Для этого была создана функция quote, а ' --- ее сокращенное обозначение. 
quote --- функция, блокирующая вычисление.

Таким образом, символ апострофа {\texttt{'}} -- функциональная блокировка, эквивалентен функции {\texttt{quote}}. Блокирует вычисление выражения. Таким образом, выражение воспринимается интерпретатором как данные.

\section*{Вопрос 3. Базис языка Lisp. Ядро языка}

Базис языка представлен:
\begin{enumerate}[label=\arabic*)]
	\item атомами;
	\item структурами;
	\item функциями:\\
	{\texttt{atom, eq, cons, car, cdr,}}\\
	{\texttt{cond, quote, lambda, eval, label}}.
\end{enumerate}

\chapter{Практические задания}

\section*{Задание 1}
Представить следующие списки в виде списочных ячеек:
\begin{enumerate}[label=\arabic*)]
	\item \texttt{'(open close halph)}
	\item \texttt{'((open1) (close2) (halph3))}
	\item \texttt{'((one) for all (and (me (for you))))}
	\item \texttt{'((TOOL) (call))}
	\item \texttt{'((TOOL1) ((call2)) ((sell)))}
	\item \texttt{'(((TOOL) (call)) ((sell)))}
\end{enumerate}

\imgScale{1}{task1.1}{\texttt{'(open close halph)}}
\imgScale{1}{task1.2}{\texttt{'((open1) (close2) (halph3))}}
\imgScale{0.5}{task1.3}{\texttt{'((one) for all (and (me (for you))))}}
\imgScale{1}{task1.4}{\texttt{'((TOOL) (call))}}
\imgScale{1}{task1.5}{\texttt{'((TOOL1) ((call2)) ((sell)))}}
\clearpage
\imgScale{1}{task1.6}{\texttt{'(((TOOL) (call)) ((sell)))}}

\section*{Задание 2}
Используя только функции \texttt{CAR} и \texttt{CDR},  написать выражения, возвращающие:
\begin{enumerate}[label=\arabic*)]
	\item второй;
	\item третий;
	\item четвёртый;
\end{enumerate}
элементы заданного списка.

Решение: 
\begin{enumerate}[label=\arabic*)]
	\item второй \texttt{(car (cdr '(1 2 3 4 5)))};
	\item третий \texttt{(car (cdr (cdr '(1 2 3 4 5))))};
	\item четвёртый \texttt{(car (cdr (cdr (cdr '(1 2 3 4 5)))))}.
\end{enumerate}

\section*{Задание 3}

Что будет в результате вычисления выражений?
\begin{enumerate}[label=\alph*)]
	\item \texttt{(CAADR '((blue cube) (red pyramid)))} // red
	\item \texttt{(CDAR '((abc) (def) (ghi)))} // Nil
	\item \texttt{(CADR '((abc) (def) (ghi)))} // (def)
	\item \texttt{(CADDR '((abc) (def) (ghi)))} // (ghi)
\end{enumerate}	

\section*{Задание 4}
Напишите результат вычисления выражений и объясните как он получен:
\begin{lstinputlisting}[
	caption={Задание 4},
	label={lst:t3},
	style={lsp},
	linerange={16-31},
	]{../src/main.lsp}
\end{lstinputlisting}

\section*{Задание 5}

Написать $\lambda$-выражение и соответствующую функцию.

\begin{itemize}[label=---]
	\item написать функцию {\texttt{(f ar1 ar2 ar3 ar4)}}, возвращающую список \\{\texttt{((ar1 ar2) (ar3 ar4))}};
	\item написать функцию {\texttt{(f ar1 ar2)}}, возвращающую список {\texttt{((ar1) (ar2))}};
	\item {\texttt{(f ar1)}}, возвращающую список {\texttt{(((ar1)))}}.
\end{itemize}


\begin{lstinputlisting}[
	caption={Задание 5},
	label={lst:t4},
	style={lsp},
	linerange={34-41},
	]{../src/main.lsp}
\end{lstinputlisting}

Результаты в виде списочных ячеек представлены на рисунках 

\imgScale{0.5}{task5.1}{\texttt{((ar1 ar2) (ar3 ar4))}}
\imgScale{0.5}{task5.2}{\texttt{((ar1) (ar2))}}
\imgScale{0.5}{task5.3}{\texttt{(((ar1)))}}